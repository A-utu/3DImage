<!doctype html>
<html lang="ja">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>SVG → 3D → GLB Exporter</title>

        <!-- ★ import map: 裸インポート 'three' を解決する -->
        <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
            }
        }
        </script>

        <style>
            html, body { margin:0; height:100%; background:#111315; }
            canvas { display:block; }
        </style>
    </head>
    <body>
        <script type="module">
            import * as THREE from "three";
            import { OrbitControls } from "three/addons/controls/OrbitControls.js";
            import { SVGLoader } from "three/addons/loaders/SVGLoader.js";
            import { GLTFExporter } from "three/addons/exporters/GLTFExporter.js";

            // ======= UI =======
            const ui = document.createElement("div");
            ui.style.position = "fixed";
            ui.style.top = "10px";
            ui.style.left = "10px";
            ui.style.padding = "12px";
            ui.style.background = "rgba(0,0,0,0.6)";
            ui.style.color = "#fff";
            ui.style.font = "14px/1.4 system-ui, sans-serif";
            ui.style.borderRadius = "10px";
            ui.style.zIndex = "10";
            ui.innerHTML = `
                <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
                    <input type="file" id="file" accept=".svg" />
                    <button id="build">3D化</button>
                    <button id="export">GLBを書き出す</button>
                </div>
                <div style="margin-top:8px; display:grid; grid-template-columns:auto auto; gap:6px; align-items:center;">
                    <label>押し出し厚み (m)</label><input id="depth" type="number" step="0.005" value="0.04" style="width:90px;">
                    <label>ベベル有効</label><input id="bevel" type="checkbox" checked>
                    <label>ベベル厚み</label><input id="bevelT" type="number" step="0.001" value="0.003" style="width:90px;">
                    <label>ベベルサイズ</label><input id="bevelS" type="number" step="0.001" value="0.003" style="width:90px;">
                    <label>色</label><input id="color" type="color" value="#ffd700" style="width:90px;">
                    <label>メタル感</label><input id="metal" type="range" min="0" max="1" step="0.05" value="0.8">
                    <label>粗さ</label><input id="rough" type="range" min="0" max="1" step="0.05" value="0.3">
                    <label>全体スケール</label><input id="scale" type="number" step="0.1" value="1.0" style="width:90px;">
                </div>
                <div style="margin-top:6px; opacity:.8;">※操作: ドラッグ=回転 / ホイール=ズーム / 右ドラッグ=パン</div>
            `;
            document.body.appendChild(ui);

            const fileInput = ui.querySelector("#file");
            const btnBuild  = ui.querySelector("#build");
            const btnExport = ui.querySelector("#export");
            const depthInput = ui.querySelector("#depth");
            const bevelChk   = ui.querySelector("#bevel");
            const bevelT     = ui.querySelector("#bevelT");
            const bevelS     = ui.querySelector("#bevelS");
            const colorInput = ui.querySelector("#color");
            const metalInput = ui.querySelector("#metal");
            const roughInput = ui.querySelector("#rough");
            const scaleInput = ui.querySelector("#scale");

            // ======= Three.js Scene =======
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111315);

            const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 100);
            camera.position.set(0.6, 0.6, 1.2);

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 0, 0);
            controls.update();

            // Lights
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const dir1 = new THREE.DirectionalLight(0xffffff, 0.8);
            dir1.position.set(1, 1, 1);
            scene.add(dir1);
            const dir2 = new THREE.DirectionalLight(0xffffff, 0.5);
            dir2.position.set(-1, 0.6, -0.8);
            scene.add(dir2);

            // Ground (optional)
            const grid = new THREE.GridHelper(4, 20, 0x444, 0x222);
            grid.position.y = -0.001;
            scene.add(grid);

            let currentGroup = null;

            function clearCurrent() {
                if (currentGroup) {
                    scene.remove(currentGroup);
                    currentGroup.traverse(o => {
                        if (o.geometry) o.geometry.dispose();
                        if (o.material) o.material.dispose?.();
                    });
                    currentGroup = null;
                }
            }

            function centerAndScale(group, userScale = 1.0) {
                const box = new THREE.Box3().setFromObject(group);
                const size = new THREE.Vector3();
                const center = new THREE.Vector3();
                box.getSize(size);
                box.getCenter(center);
                group.position.sub(center);
                group.scale.setScalar(userScale);
            }

            async function buildFromSVGFile(file) {
                if (!file) {
                    alert("SVGファイルを選択してください。");
                    return;
                }
                const svgText = await file.text();
                const loader = new SVGLoader();
                const data = loader.parse(svgText);

                clearCurrent();

                const group = new THREE.Group();

                const color = new THREE.Color(colorInput.value);
                const material = new THREE.MeshStandardMaterial({
                    color,
                    metalness: parseFloat(metalInput.value),
                    roughness: parseFloat(roughInput.value),
                    side: THREE.DoubleSide,
                });

                const extrudeSettings = {
                    depth: parseFloat(depthInput.value),
                    bevelEnabled: bevelChk.checked,
                    bevelThickness: parseFloat(bevelT.value),
                    bevelSize: parseFloat(bevelS.value),
                    bevelSegments: 4,
                    curveSegments: 12,
                    steps: 1
                };

                for (const p of data.paths) {
                    const shapes = SVGLoader.createShapes(p);
                    for (const s of shapes) {
                        const geo = new THREE.ExtrudeGeometry(s, extrudeSettings);
                        geo.computeVertexNormals();
                        const mesh = new THREE.Mesh(geo, material);
                        // SVG座標系(Y下向き)→Three(Y上向き)
                        group.add(mesh);
                    }
                }

                centerAndScale(group, parseFloat(scaleInput.value));
                group.position.y += parseFloat(depthInput.value) / 2;

                currentGroup = group;
                scene.add(group);
            }

            btnBuild.addEventListener("click", async () => {
                try {
                    await buildFromSVGFile(fileInput.files?.[0]);
                } catch (e) {
                    console.error(e);
                    alert("SVGの3D化でエラー。SVGの余白を詰める、塗りのみで出力、で再保存してみてください。");
                }
            });

            btnExport.addEventListener("click", () => {
                if (!currentGroup) {
                    alert("まずSVGを3D化してください。");
                    return;
                }
                const root = new THREE.Scene();
                root.add(currentGroup.clone(true));

                // ★ GLBで書き出す（1ファイル・バイナリ）
                const exporter = new GLTFExporter();
                exporter.parse(
                    currentGroup,                 // or root/sceneでもOK
                    (arrayBuffer) => {
                        const blob = new Blob([arrayBuffer], { type: 'model/gltf-binary' });
                        const a = document.createElement('a');
                        a.href = URL.createObjectURL(blob);
                        a.download = 'congrats.glb';
                        a.click();
                        URL.revokeObjectURL(a.href);
                        console.log('[export] GLB done');
                    },
                    { binary: true }              // ← これが超重要！
                );
            });

            window.addEventListener("resize", () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            renderer.setAnimationLoop(() => {
                renderer.render(scene, camera);
            });
        </script>
    </body>
</html>
